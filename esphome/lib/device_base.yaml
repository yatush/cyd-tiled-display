esp32:
  board: esp32dev
  framework:
    type: arduino

spi:
  - id: tft
    clk_pin: GPIO14
    mosi_pin: GPIO13
    miso_pin: GPIO12
  - id: touch
    clk_pin: GPIO25
    mosi_pin: GPIO32
    miso_pin: GPIO39

output:
  - platform: ledc
    pin: GPIO21
    id: backlight_pwm
  - platform: ledc
    id: output_red
    pin: GPIO4
    inverted: true
  - platform: ledc
    id: output_green
    pin: GPIO16
    inverted: true
  - platform: ledc
    id: output_blue
    pin: GPIO17
    inverted: true

uart:
  tx_pin: GPIO22
  rx_pin: GPIO27
  baud_rate: 256000
  parity: NONE
  stop_bits: 1

sensor:
  - platform: adc
    pin: GPIO34
    id: board_ldr
    name: "board_ldr"
    update_interval: 1000ms
    entity_category: "diagnostic"
    accuracy_decimals: 3
    internal: true

globals:
  - id: render_diffs
    type: bool
    initial_value: "true"
  - id: width
    type: int
    initial_value: "320"
  - id: height
    type: int
    initial_value: "240"
  - id: tile_border_width
    type: int
    initial_value: "1"

script:
  - id: init_tile_fonts
    then:
      - lambda: |-
          TileFonts::fonts[TileFonts::Size::BIG] = id(mdi_80);
          TileFonts::fonts[TileFonts::Size::MEDIUM] = id(mdi_60);
          TileFonts::fonts[TileFonts::Size::SMALL] = id(mdi_40);
          TileFonts::fonts[TileFonts::Size::TINY] = id(mdi_24);
          TileFonts::fonts[TileFonts::Size::TEXT_BOLD] = id(roboto_20_bold);
          TileFonts::fonts[TileFonts::Size::TEXT] = id(roboto_20);
          TileFonts::fonts[TileFonts::Size::TEXT_SMALL] = id(roboto_12);
          TileFonts::fonts[TileFonts::Size::TEXT_BIG_BOLD] = id(roboto_30_bold);

display:
  - platform: ili9xxx
    update_interval: 10s
    model: ili9341
    spi_id: tft
    color_palette: 8BIT
    cs_pin: GPIO15
    dc_pin: GPIO2
    id: disp
    transform: { mirror_y: true }
    dimensions:
      width: 320
      height: 240
    invert_colors: false
    on_page_change:
      then:
        - lambda: |-
            id(change_page_ms) = millis();
    pages:
      - id: calib
        lambda: |-
          if (id(touch_calibration).state) {
            id(disp).fill(id(Color::WHITE));
            id(disp).filled_circle(id(last_x), id(last_y), 10, id(red));
            id(disp).printf(id(width) / 2, id(height) / 2 - 15, id(roboto_20), Color::BLACK, TextAlign::CENTER,
                          "x=%d, y=%d", id(last_x), id(last_y));
            id(disp).printf(id(width) / 2, id(height) / 2 + 15, id(roboto_20), Color::BLACK, TextAlign::CENTER,
                          "x_raw=%d, y_raw=%0d", id(last_x_raw), id(last_y_raw));
          }

      - id: pref
        lambda: |-
          id(draw_page).execute();

      - id: controllers
        lambda: |-
          id(draw_page).execute();

      - id: ac_settings
        lambda: |-
          id(draw_page).execute();

      - id: disp_settings
        lambda: |-
          id(draw_page).execute();

      - id: light_settings
        lambda: |-
          id(draw_page).execute();

      - id: cover_settings
        lambda: |-
          id(draw_page).execute();

      - id: cover_settings_2
        lambda: |-
          id(draw_page).execute();

touchscreen:
  id: touchscreen_id
  platform: xpt2046
  spi_id: touch
  cs_pin: GPIO33
  threshold: 400
  calibration: { x_min: 360, x_max: 3780, y_min: 320, y_max: 3800 }
  transform:
    swap_xy: true
  on_touch:
    then:
      - light.turn_on: backlight
      - lambda: |-
          auto now = millis();
          id(last_activity_ms) = now;
          id(last_touch_ms) = now;
          id(last_x) = touch.x;
          id(last_y) = touch.y;
          if (id(turn_on_ms) == 0) {
            id(turn_on_ms) = now;
          }
          if (id(touch_calibration).state) {
            id(last_x) = touch.x;
            id(last_y) = touch.y;
            id(last_x_raw) = touch.x_raw;
            id(last_y_raw) = touch.y_raw;
          }
