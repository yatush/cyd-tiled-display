esphome:
  on_boot:
    then:
      - script.execute: init_radar
      
packages:
  custom_lib: !include lib_custom.yaml

substitutions:
  api_port: "6053"

logger:

api:
  id: api_server
  port: ${api_port}

globals:
  - id: rows
    type: int
    initial_value: "2"
  - id: cols
    type: int
    initial_value: "3"
  - id: wifi_iconstring
    type: std::string
    restore_value: no
    initial_value: '"\U0000f063"'
  - id: wifi_color
    type: Color
    initial_value: "Color(128, 128, 128)"
  - id: last_x
    type: int
  - id: last_y
    type: int
  - id: last_x_raw
    type: int
  - id: last_y_raw
    type: int
  - id: last_activity_ms
    type: unsigned long
    initial_value: "0"
  - id: last_touch_ms
    type: unsigned long
    initial_value: "0"
  - id: turn_on_ms
    type: unsigned long
    initial_value: "1" # This is one to differ from other times where it is 0 and the backlight is off.
  - id: sleep_time
    type: int
    restore_value: yes
    initial_value: "60"
  - id: adaptive_brightness
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: wakeup_distance
    type: int
    restore_value: yes
    initial_value: "100"
  - id: inactive_ms
    type: unsigned long
    initial_value: "500"
  - id: between_pages_ms
    type: unsigned long
    initial_value: "500"
  - id: change_page_ms
    type: unsigned long
    initial_value: "0"
  - id: bright_start_press_ms
    type: unsigned long
    initial_value: "0"
  - id: inactive_back_to_base_sec
    type: int
    initial_value: "60"
  - id: x_pad
    type: int
    initial_value: "10"
  - id: y_pad
    type: int
    initial_value: "10"
  - id: border_r
    type: int
    initial_value: "8"
  - id: script_output
    type: bool
    initial_value: "false"
    # Internal variable used to return values from scripts. Do not modify manually.
  - id: binary_sensors
    type: std::map<std::string, esphome::homeassistant::HomeassistantBinarySensor* >
  - id: text_sensors
    type: std::map<std::string, esphome::homeassistant::HomeassistantTextSensor* >
  - id: entities_map
    type: std::map<const std::string*, std::set<const std::string*>>

# This is now standard RGB
color:
  - id: blue
    hex: "0000FF"
  - id: light_blue
    hex: "3333aa"
  - id: red
    hex: "FF0000"
  - id: light_red
    hex: "aa3333"
  - id: light_green
    hex: "33aa33"
  - id: light_purple
    hex: "aa33aa"
  - id: gray
    red: 50%
    green: 50%
    blue: 50%
  - id: dark_gray
    red: 30%
    green: 30%
    blue: 30%
  - id: dark_dark_gray
    red: 20%
    green: 20%
    blue: 20%
  - id: yellow
    hex: "FFFF00"
  - id: light_yellow
    hex: "aaaa33"

number:
  - platform: template
    name: "Wakeup distance"
    id: "wakeup_distance_connect"
    min_value: 0
    max_value: 300
    step: 50
    device_class: distance
    unit_of_measurement: "cm"
    lambda: |-
      return id(wakeup_distance);
    set_action:
      then:
        - globals.set:
            id: wakeup_distance
            value: !lambda "return x;"

  - platform: template
    name: "Sleep time"
    id: "sleep_time_connect"
    min_value: 15
    max_value: 960
    step: 1
    device_class: duration
    unit_of_measurement: "sec"
    lambda: |-
      return id(sleep_time);
    set_action:
      then:
        - globals.set:
            id: sleep_time
            value: !lambda "return x;"

light:
  - platform: monochromatic
    output: backlight_pwm
    name: Display Backlight
    id: backlight
    restore_mode: ALWAYS_ON
    on_turn_on:
      then:
        - component.update: disp
        - lambda: |-
            id(last_activity_ms) = millis();

switch:
  - platform: template
    id: touch_calibration
    name: Touch calibration
    optimistic: true
    on_turn_off:
      then:
        - if:
            condition:
              - lambda: 'return !View::initialized;'
            then:
              - delay: 2500ms
        - lambda: |-
            id(disp).show_page(view_ptr->getBaseScreen()->getDisplayPage());
    on_turn_on:
      then:
        - display.page.show: calib

binary_sensor:
  - platform: homeassistant
    id: dummy_dont_delete
    entity_id: dummy.entity
    internal: true

  - platform: touchscreen
    name: Dummy2
    id: btn_dummy_dont_delete
    x_min: 0
    x_max: 0
    y_min: 0
    y_max: 0
    internal: true

text_sensor:
  - platform: homeassistant
    id: dummy_dont_delete2
    entity_id: dummy.dummy
    internal: true

script:
  # Dummy script to force USER_API_HOMEASSISTANT_SERVICES to be defined
  - id: _force_ha_services
    then:
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.dummy

  - id: increase_bright
    then:
      - lambda: |-
          auto new_brightness = id(backlight).remote_values.get_brightness() + 0.1;
          if (new_brightness > 1.01 || new_brightness < 0.3) {
            new_brightness = 0.3;
          }
          id(backlight).make_call().set_brightness(new_brightness).set_transition_length(0).perform();

  - id: handle_touch
    mode: restart
    parameters:
      x: int
      y: int
      x_raw: int
      y_raw: int
    then:
      - light.turn_on: backlight
      - lambda: |-
          auto now = millis();
          id(last_activity_ms) = now;
          id(last_touch_ms) = now;
          id(last_x) = x;
          id(last_y) = y;
          if (id(turn_on_ms) == 0) {
            id(turn_on_ms) = now;
          }
          if (id(touch_calibration).state) {
            id(last_x) = x;
            id(last_y) = y;
            id(last_x_raw) = x_raw;
            id(last_y_raw) = y_raw;
          }

  - id: on_brightness_press
    then:
      - lambda: |-
          id(adaptive_brightness) = false;
          id(bright_start_press_ms) = millis();
          id(increase_bright).execute();
          id(disp).update();

  - id: on_brightness_release
    then:
      - lambda: |-
          id(bright_start_press_ms) = 0;

  - id: rounded_rectangle
    parameters: { x: int, y: int, w: int, h: int, r: int, c: Color }
    then:
      - lambda: |-
          id(disp).start_clipping(x, y, x + r + 1, y + r + 1);
          circle(x + r, y + r, r, c);
          id(disp).end_clipping();

          id(disp).start_clipping(x + w - r - 1, y, x + w, y + r + 1);
          circle(x + w - r - 1, y + r, r, c);
          id(disp).end_clipping();

          id(disp).start_clipping(x + w - r - 1, y + h - r, x + w, y + h);
          circle(x + w - r - 1, y + h - r - 1, r, c);
          id(disp).end_clipping();

          id(disp).start_clipping(x, y + h - r - 1, x + r + 1, y + h);
          circle(x + r, y + h - r - 1, r, c);
          id(disp).end_clipping();

          id(disp).start_clipping(x + r, y, x + w - r, y + h);
          rectangle(x + r - 1, y, w - 2 * r + 2, h, c);
          id(disp).end_clipping();

          id(disp).start_clipping(x, y + r, x + w, y + h - r);
          rectangle(x, y + r - 1, w, h - 2 * r + 2, c);
          id(disp).end_clipping();

  - id: change_sleep_time
    then:
      - lambda: |-
          id(sleep_time) *= 2;
          if (id(sleep_time) >= 1920) {
            id(sleep_time) = 15;
          }
          id(sleep_time_connect).update();

  - id: change_wakeup_distance
    then:
      - lambda: |-
          id(wakeup_distance) += 50;
          id(wakeup_distance) %= 350;
          id(wakeup_distance_connect).update();

  - id: on_movement
    then:
      - lambda: |-
          if (id(wakeup_distance) == 0 ||
              !id(radar_has_moving_target).state ||
              id(moving_distance)->state > id(wakeup_distance)) {
            return;
          }
          auto now = millis();
          if (!id(backlight).remote_values.is_on()) {
            id(backlight).turn_on().perform();
            id(turn_on_ms) = now;
          }
          id(last_activity_ms) = now;

  - id: update_ui_values
    then:
      - lambda: |-
          if (isnan(id(wifi_signal_pct).state) ||
              id(wifi_signal_pct).state < 30)
            id(wifi_color) = id(light_red);
          else if (id(wifi_signal_pct).state >= 60)
            id(wifi_color) = id(light_green);
          else
            id(wifi_color) = id(gray);

          if (isnan(id(wifi_signal_pct).state))
            id(wifi_iconstring) = "\U0000f063"; // No-wifi
          else if (id(wifi_signal_pct).state < 10)
            id(wifi_iconstring) = "\U0000f0b0";  // low-wifi
          else if (id(wifi_signal_pct).state < 30)
            id(wifi_iconstring) = "\U0000ebe4"; // wifi-1
          else if (id(wifi_signal_pct).state < 50)
            id(wifi_iconstring) = "\U0000ebd6"; // wifi-2
          else if (id(wifi_signal_pct).state < 75)
            id(wifi_iconstring) = "\U0000ebe1"; // wifi-3
          else
            id(wifi_iconstring) = "\U0000e1d8"; // wifi-4
  
  - id: blinds_moving_down_fn
    parameters:
      covers: string[]
    then:
      - lambda: |-
          id(script_output) = std::any_of(covers.begin(), covers.end(), [](const std::string& cover) { return GetTextSensorValue(cover) == "closing"; });
  
  - id: blinds_moving_up_fn
    parameters:
      covers: string[]
    then:
      - lambda: |-
          id(script_output) = std::any_of(covers.begin(), covers.end(), [](const std::string& cover) { return GetTextSensorValue(cover) == "opening"; });

  - id: draw_tile_frame
    parameters:
      i: int
      j: int
      i_span: int
      j_span: int
    then:
      - lambda: |-
          for (int delta = 0; delta < id(tile_border_width); ++delta) {
            id(rounded_rectangle).execute(
              x_start(i)+delta, 
              y_start(j)+delta, 
              x_rect() * i_span + (i_span - 1) * id(x_pad) - 2 * delta,
              y_rect() * j_span + (j_span - 1) * id(y_pad) - 2 * delta,
              id(border_r) - delta,
              id(gray));
          }

  - id: tile_blinds_up
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          bool up = DRAW_ONLY(RUN_SCRIPT(id(blinds_moving_up_fn), entities));
          uint32_t millis_val = DRAW_ONLY(millis());
          handle_caching(std::make_pair(x_start, y_start), millis_val, up);
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          if (up) {
            print(x_mid, y_mid - static_cast<int>(millis_val / 1000.0 * 12) % 41 + 20, id(big), id(blue), TextAlign::CENTER, "\U0000eacf");
          } else {
            print(x_mid, y_mid, id(big), id(light_blue), TextAlign::CENTER, "\U0000eacf");
          }

  - id: action_blinds_up
    parameters:
      entities: string[]
    then:
      - lambda: |-
          bool up = RUN_SCRIPT(id(blinds_moving_up_fn), entities);
          static const char* STOP_COVER = "stop_cover";
          static const char* OPEN_COVER = "open_cover";
          for (const std::string& blind : entities) {
            PerformHaAction(blind, up ? STOP_COVER : OPEN_COVER);
          }
 
  - id: tile_blinds_down
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          bool down = DRAW_ONLY(RUN_SCRIPT(id(blinds_moving_down_fn), entities));
          uint32_t millis_val = DRAW_ONLY(millis());
          handle_caching(std::make_pair(x_start, y_start), millis_val, down);
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          if (down) {
            print(x_mid, y_mid + static_cast<int>(millis_val / 1000.0 * 12) % 41 - 20, id(big), id(red), TextAlign::CENTER, "\U0000ead0");
          } else {
            print(x_mid, y_mid, id(big), id(light_red), TextAlign::CENTER, "\U0000ead0");
          }

  - id: action_blinds_down
    parameters:
      entities: string[]
    then:
      - lambda: |-
          bool down = RUN_SCRIPT(id(blinds_moving_down_fn), entities);
          static const char* STOP_COVER = "stop_cover";
          static const char* CLOSE_COVER = "close_cover";
          for (const std::string& blind : entities) {
            PerformHaAction(blind, down ? STOP_COVER : CLOSE_COVER);
          }

  - id: action_blinds_mid
    parameters:
      entities: string[]
    then:
      - lambda: |-
          static std::string set_cover_position = "set_cover_position";
          static const char* SET_COVER_POSITION = "set_cover_position";
          static const char* POSITION = "position";
          static const char* FOURTY = "40";
          for (const std::string& blind : entities) {
            PerformHaAction(blind, SET_COVER_POSITION, {{POSITION, FOURTY}});
          }

  - id: action_blinds_up_down
    parameters:
      x: float
      y: float
      entities: string[]
    then:
      - lambda: |-
          static const char* STOP_COVER = "stop_cover";
          static const char* OPEN_COVER = "open_cover";
          static const char* CLOSE_COVER = "close_cover";
          bool up = RUN_SCRIPT(id(blinds_moving_up_fn), entities);
          bool down = RUN_SCRIPT(id(blinds_moving_down_fn), entities);
          for (const std::string& blind : entities) {
            if (up || down) {
              PerformHaAction(blind, STOP_COVER);
            } else {
              PerformHaAction(blind, (x + y < 1) ? OPEN_COVER : CLOSE_COVER);
            }
          }

  - id: tile_blinds_up_down
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          bool up = DRAW_ONLY(RUN_SCRIPT(id(blinds_moving_up_fn), entities));
          bool down = DRAW_ONLY(RUN_SCRIPT(id(blinds_moving_down_fn), entities));
          uint32_t millis_val = DRAW_ONLY(millis());
          handle_caching(std::make_pair(x_start, y_start), millis_val, up, down);
          bool one = up != down;
          bool any = up || down;
          bool show_up = !one || up;
          bool show_down = !one || down;

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          int x_rect = x_end - x_start;
          int y_rect = y_end - y_start;

          auto delta_x = one ? 0 : x_rect / 5;
          auto delta_y = any ? static_cast<int>(millis_val / 1000.0 * 12) % 41 - 20 : y_rect / 5;
          int text_x = x_mid + (show_up ? -1 : 1) * delta_x;
          int text_y = y_mid + (show_up ? -1 : 1) * delta_y;
          auto color = show_up ? id(blue) : id(red);
          const char* symbol = show_up ? "\U0000eacf" : "\U0000ead0";
          print(text_x, text_y, one ? id(big) : id(small), color, TextAlign::CENTER, symbol);

          if (show_up) {
            if (one) {
              print(x_mid - delta_x, y_mid - delta_y, id(big), id(blue), TextAlign::CENTER, "\U0000eacf");
            } else {
              print(x_mid - delta_x, y_mid - delta_y, id(small), id(blue), TextAlign::CENTER, "\U0000eacf");
            }
          }
          if (show_down) {
            if (one) {
              print(x_mid + delta_x, y_mid + delta_y, id(big), id(red), TextAlign::CENTER, "\U0000ead0");
            } else {
              print(x_mid + delta_x, y_mid + delta_y, id(small), id(red), TextAlign::CENTER, "\U0000ead0");
            }
          }

          if (!any) {
            int gap = x_rect / 6;
            line(x_start + gap, y_start + y_rect - gap, x_start + x_rect - gap, y_start + gap, id(gray));
          }

  - id: tile_lights
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          print(x_mid, y_mid, id(big), IsAnyOn(entities) ? id(yellow) : id(gray), TextAlign::CENTER, "\U0000e0f0");

  - id: action_lights
    parameters:
      entities: string[]
    then:
      - lambda: |-
          static const char* TURN_ON = "turn_on";
          static const char* TURN_OFF = "turn_off";
          std::string action = IsAnyOn(entities) ? TURN_OFF : TURN_ON;
          for (const std::string& light : entities) {
            PerformHaAction(light, action);
          }

  - id: tile_ac
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          auto state = entities.empty() ? "none" : GetTextSensorValue(entities.at(0)).c_str();
          print(x_mid, y_mid, id(big),
                      strcmp(state, "cool") == 0   ? id(blue) : strcmp(state, "heat") == 0 ? id(red) : id(gray),
                      TextAlign::CENTER, "\U0000f154");

  - id: action_ac
    parameters:
      entities: string[]
    then:
     - lambda: |-
          static const char* TURN_ON = "turn_on";
          static const char* TURN_OFF = "turn_off";
          std::string action = IsAnyOn(entities) ? TURN_OFF : TURN_ON;
          for (const std::string& ac : entities) {
            PerformHaAction(ac, action);
          }

  - id: tile_brightness
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
    then:
      - lambda: |-
          int brightness = DRAW_ONLY(id(backlight).remote_values.get_brightness() * 100);
          bool adapt = DRAW_ONLY(id(adaptive_brightness));
          handle_caching(std::make_pair(x_start, y_start), brightness, adapt);
          
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          int x_rect = x_end - x_start;
          int y_rect = y_end - y_start;

          std::string icon = "\U0000e518";
          auto icon_size = measure(id(medium), icon.c_str());
          int slider_width = x_rect / 9 * 7;
          int slider_height = y_rect / 9 / 2 * 2;
          int slider_start = x_start + (x_rect - slider_width) / 2 + 1;
          int y_gap = 2;
          auto auto_size = measure(id(text_bold), "0");
          int icon_y = y_mid - (auto_size.second + y_gap) / 2;
          int slider_y = y_mid + (icon_size.second + y_gap) / 2;

          print(x_mid, icon_y, id(medium), id(light_yellow), TextAlign::CENTER, icon.c_str());
          filled_rectangle(
              slider_start + 1, slider_y - slider_height / 2 + 1,
              brightness * slider_width / 100 - 2,
              slider_height - 2, adapt ? id(dark_gray) : id(yellow));
          rectangle(slider_start, slider_y - slider_height / 2, slider_width, slider_height, adapt ? id(gray) : id(light_yellow));
          if (adapt) {
            print(x_mid, slider_y, id(text_bold), id(yellow), TextAlign::CENTER, "Auto");
          }

  - id: tile_wakeup_time
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
    then:
      - lambda: |-
          int sleep_t = DRAW_ONLY(id(sleep_time));
          int counter = DRAW_ONLY(((millis() - id(last_activity_ms)) / 1000)); 
          handle_caching(std::make_pair(x_start, y_start), sleep_t, counter);

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;

          std::string icon = "\U0000e425";
          auto icon_size = measure(id(medium), icon.c_str());
          auto time_size = measure(id(text_regular), "0");
          auto counter_size = measure(id(text_small), "0");

          int icon_y = y_mid - time_size.second / 2;
          int time_y = y_mid + icon_size.second / 2;
          int counter_y = icon_y + counter_size.second / 2 + icon_size.second / 12;

          print(x_mid, icon_y, id(medium), id(light_purple), TextAlign::CENTER, icon.c_str());
          printf(x_mid, time_y, id(text_regular), id(light_purple), TextAlign::CENTER, "%d", sleep_t);
          printf(x_mid, counter_y, id(text_small), id(light_blue), TextAlign::CENTER, "%d", counter);

  - id: tile_distance
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
    then:
      - lambda: |-
          int wakeup_dist = DRAW_ONLY(id(wakeup_distance));
          bool nan_moving_dist = DRAW_ONLY(isnan(id(moving_distance).state));
          int moving_dist = DRAW_ONLY(id(moving_distance).state);
          handle_caching(std::make_pair(x_start, y_start), wakeup_dist, moving_dist, nan_moving_dist);

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          int y_rect = y_end - y_start;

          if (wakeup_dist == 0) {
            print(x_mid, y_mid, id(medium), id(gray), TextAlign::CENTER, "\U0000e913");
          } else {
            // Strings
            std::string icon = "\U0000e536";
            std::string cm = "< c m >";
            
            // Sizes
            auto icon_size = measure(id(medium), icon.c_str());
            auto cm_size = measure(id(text_small), cm.c_str());
            auto numbers_size = measure(id(text_bold), "0");

            int icon_y = y_mid - numbers_size.second / 2;

            int x_diff = std::abs(icon_size.first - cm_size.first);
            int delta_x = std::max(icon_size.first, cm_size.first) / 2 + std::max(0, y_rect / 18 - x_diff);

            auto person_color = id(radar_has_moving_target).state ? id(red) : id(gray);
            auto numbers_color = wakeup_dist > moving_dist ? id(light_red) : id(gray);

            printf(x_mid + delta_x, icon_y - numbers_size.second / 2 - cm_size.second / 2, id(text_bold), numbers_color, TextAlign::CENTER, "%d", wakeup_dist);
            printf(x_mid + delta_x, icon_y, id(text_small), numbers_color, TextAlign::CENTER, cm.c_str());
            print(x_mid - delta_x, icon_y, id(medium), person_color, TextAlign::CENTER, icon.c_str());
            int bottom_y = y_mid + icon_size.second / 2;
            if (nan_moving_dist) {
              printf(x_mid, bottom_y, id(text_regular), id(gray), TextAlign::CENTER, "------");
            } else {
              printf(x_mid, bottom_y, id(text_regular), numbers_color, TextAlign::CENTER, "%dcm", moving_dist);
            }
          }

  - id: tile_icon
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      icon: string
      color: Color
      size: esphome::display::BaseFont*
    then:
      - lambda: |-
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          print(x_mid, y_mid, size, color, TextAlign::CENTER, icon.c_str());
  
  - id: tile_text
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      text: string
      color: Color
      size: esphome::display::BaseFont*
    then:
      - lambda: |-
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          print(x_mid, y_mid, size, color, TextAlign::CENTER, text.c_str());

  - id: action_power
    then:
      - lambda: |-
          id(restart_button).press();

  - id: tile_choose_light
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      name: string
      is_on: bool
    then:
      - lambda: |-
          std::string cur_name = DRAW_ONLY(name);
          bool cur_is_on = DRAW_ONLY(is_on);
          handle_caching(std::make_pair(x_start, y_start), cur_is_on, cur_name);
          
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;

          std::string icon = "\U0000f02a";
          // Sizes
          auto icon_size = measure(id(medium), icon.c_str());
          auto text_size = measure(id(text_bold), "0");

          int icon_y = y_mid - text_size.second / 2;
          int text_y = y_mid + icon_size.second / 2;

          print(x_mid, icon_y, id(medium), cur_is_on ? id(yellow) : id(gray), TextAlign::CENTER, icon.c_str());
          print(x_mid, text_y, id(text_bold), Color::WHITE, TextAlign::CENTER, cur_name.c_str());

  - id: tile_choose_cover
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      name: string
      is_on: bool
    then:
      - lambda: |-
          std::string cur_name = DRAW_ONLY(name);
          bool cur_is_on = DRAW_ONLY(is_on);
          handle_caching(std::make_pair(x_start, y_start), cur_is_on, cur_name);

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;

          std::string icon = "\U0000e286";
          // Sizes
          auto icon_size = measure(id(medium), icon.c_str());
          auto text_size = measure(id(text_bold), "0");

          int icon_y = y_mid - text_size.second / 2;
          int text_y = y_mid + icon_size.second / 2;

          print(x_mid, icon_y, id(medium), cur_is_on ? id(yellow) : id(gray), TextAlign::CENTER, icon.c_str());
          print(x_mid, text_y, id(text_bold), Color::WHITE, TextAlign::CENTER, cur_name.c_str());

  - id: tile_cover_name
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      name: string
      entities: string[]
    then:
      - lambda: |-
          std::vector<std::string> my_entities = DRAW_ONLY(entities);
          std::string cur_name = DRAW_ONLY(name);
          handle_caching(std::make_pair(x_start, y_start), cur_name, my_entities);

          if (my_entities.empty()) return;

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          int x_rect = x_end - x_start;

          std::string icon = "\U0000e286";
          // Sizes
          auto icon_size = measure(id(medium), icon.c_str());
          auto text_size = measure(id(text_bold), "0");

          int icon_y = y_mid - text_size.second / 2;
          int text_y = y_mid + icon_size.second / 2;

          print(x_start + 15, icon_y, id(tiny), id(gray), TextAlign::CENTER, "\U0000e5cb");
          print(x_start + x_rect - 15, icon_y, id(tiny), id(gray), TextAlign::CENTER, "\U0000e5cc");
          print(x_mid, icon_y, id(medium), id(gray), TextAlign::CENTER, icon.c_str());
          print(x_mid, text_y, id(text_bold), Color::WHITE, TextAlign::CENTER, cur_name.c_str());
          std::string common_position = "";
          bool all_same = true;
          for (size_t i = 0; i < my_entities.size(); ++i) {
            std::string pos = GetTextSensorValue(my_entities[i] + "|current_position");
            if (i == 0) {
              common_position = pos;
            } else if (pos != common_position) {
              all_same = false;
              break;
            }
          }
          if (all_same && !common_position.empty()) {
            std::string position_str = common_position + "%";
            print(x_mid, text_y - (text_size.second), id(text_bold), Color::WHITE, TextAlign::CENTER, position_str.c_str());
          }

  - id: tile_room
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      name: string
    then:
      - lambda: |-
          std::string cur_name = DRAW_ONLY(name);
          handle_caching(std::make_pair(x_start, y_start), cur_name);

          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          int x_rect = x_end - x_start;

          std::string icon = "\U0000e88a";
          // Sizes
          auto icon_size = measure(id(medium), icon.c_str());
          auto text_size = measure(id(text_bold), "0");

          int icon_y = y_mid - text_size.second / 2;
          int text_y = y_mid + icon_size.second / 2;

          print(x_start + 15, icon_y, id(tiny), id(gray), TextAlign::CENTER, "\U0000e5cb");
          print(x_start + x_rect - 15, icon_y, id(tiny), id(gray), TextAlign::CENTER, "\U0000e5cc");
          print(x_mid, icon_y, id(medium), id(gray), TextAlign::CENTER, icon.c_str());
          print(x_mid, text_y, id(text_bold), Color::WHITE, TextAlign::CENTER, cur_name.c_str());

  - id: action_temp_up
    parameters:
      entities: string[]
    then:
      - lambda: |-
          for (const std::string& ac : entities) {
            std::string temp = GetTextSensorValue(ac);
            if (IsInteger(temp)) {
              int new_temp = stoi(temp) + 1;
              PerformHaAction(GetSensor(ac), "set_temperature", {{"temperature", std::to_string(new_temp)}});
            } else {
              ESP_LOGE("ActionTempUp", "Failed getting temp for %s", ac.c_str());
            }
          }

  - id: action_temp_down
    parameters:
      entities: string[]
    then:
      - lambda: |-
          for (const std::string& ac : entities) {
            std::string temp = GetTextSensorValue(ac);
            if (IsInteger(temp)) {
              int new_temp = stoi(temp) - 1;
              PerformHaAction(GetSensor(ac), "set_temperature", {{"temperature", std::to_string(new_temp)}});
            } else {
              ESP_LOGE("ActionTempDown", "Failed getting temp for %s", ac.c_str());
            }
          }

  - id: tile_ac_mode
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
    then:
      - lambda: |-
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          print(x_mid, y_mid, id(text_big_bold), id(gray), TextAlign::CENTER, "Mode");

  - id: action_ac_mode
    parameters:
      entities: string[]
    then:
      - lambda: |-
          for (const std::string& ac : entities) {
            std::string current = GetTextSensorValue(ac);
            static const char* OFF = "off";
            static const char* COOL = "cool";
            static const char* HEAT = "heat";
            const char* next = (current == OFF) ? COOL : (current == COOL) ? HEAT : OFF;
            PerformHaAction(GetSensor(ac), "set_hvac_mode", {{"hvac_mode", std::string(next)}});
          }

  - id: tile_ac_status
    parameters:
      x_start: int
      x_end: int
      y_start: int
      y_end: int
      entities: string[]
    then:
      - lambda: |-
          if (entities.size() != 2) {
            return;
          }
          std::string state = DRAW_ONLY(entities[0]);
          std::string entity = DRAW_ONLY(entities[1]);
          handle_caching(std::make_pair(x_start, y_start), state, entity);
          int x_mid = (x_start + x_end) / 2;
          int y_mid = (y_start + y_end) / 2;
          print(x_mid, y_mid, id(text_big_bold), id(gray), TextAlign::CENTER, (GetTextSensorValue(state) + " " + GetTextSensorValue(entity) + "Â°").c_str());

  - id: draw_page
    then:
      - lambda: |-
          if (!View::initialized) {
            ESP_LOGE("DrawPage", "Calling DrawPage when View not initialized. You should never see it after initialization");
            return;
          }
          if (!id(backlight).remote_values.is_on()) {
            return;
          }
          id(update_ui_values).execute();
          view_ptr->getActiveScreen()->draw();

interval:
  - interval: 250ms
    then:
      - script.execute: on_movement
      - if:
          condition:
            or:
              - lambda: "return id(disp).get_active_page() == id(calib);"
              - lambda: "if (!View::initialized) return false; return view_ptr->getActiveScreen()->hasAtt(FAST_REFRESH);"
          then:
            - component.update: disp
      - if:
          condition:
            - lambda: "return id(bright_start_press_ms) != 0;"
          then:
            - lambda: |-
                if (millis() - id(bright_start_press_ms) > 2000) {
                  id(adaptive_brightness) = true;
                  id(bright_start_press_ms) = 0;
                }

  - interval: 1s
    then:
      # Adapt brightness
      - if:
          condition:
            - lambda: |-
                return id(adaptive_brightness);
          then:
            - script.execute: adapt_bright
      # Turn off screen if needed.
      - if:
          condition:
            - lambda: |-
                if (!id(backlight).remote_values.is_on())
                  return false;
                return (millis() - id(last_activity_ms)) > id(sleep_time) * 1000;
          then:
            - lambda: |-
                id(backlight).turn_off().perform();
                id(turn_on_ms) = 0;
      # Leave temporary screens after too much inactivity there.
      - lambda: |-
          if (!View::initialized) {
            return;
          }
          if (id(disp).get_active_page() != id(calib) &&
              view_ptr->getActiveScreen()->hasAtt(TEMPORARY) &&
              ((millis() - id(last_touch_ms)) > (id(inactive_back_to_base_sec) * 1000))) {
            view_ptr->getActiveScreen()->onScreenLeave();
            id(disp).show_page(view_ptr->getBaseScreen()->getDisplayPage());
            id(disp).update();
          }
